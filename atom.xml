<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Attractor Software Blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://attractor-software.github.io/"/>
  <updated>2018-03-30T07:30:12.632Z</updated>
  <id>https://attractor-software.github.io/</id>
  
  <author>
    <name>Attractor Software LLC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Digits Recognizer using Python and React. Build backend with Flask.</title>
    <link href="https://attractor-software.github.io/2018/03/26/digits-recognizer-2/"/>
    <id>https://attractor-software.github.io/2018/03/26/digits-recognizer-2/</id>
    <published>2018-03-26T06:40:52.000Z</published>
    <updated>2018-03-30T07:30:12.632Z</updated>
    
    <content type="html"><![CDATA[<p>It is the second part of my long journey to creating the web application for recognition handwritten digits. Here I’ll explain how to integrate our trained model into the Flask application.</p><h2 id="Set-up-environment"><a href="#Set-up-environment" class="headerlink" title="Set up environment"></a>Set up environment</h2><p>As we’ll build the application from scratch we need to create a virtual environment in order to incapsulate all our dependencies. Let’s create python3 virtual environment.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure></p><p>Now we have the environment and we can install all needed dependencies.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask flask-script scipy scikit-image numpy pillow</span><br></pre></td></tr></table></figure></p><p>That’s all about setting up the environment.</p><h2 id="Configure-application"><a href="#Configure-application" class="headerlink" title="Configure application"></a>Configure application</h2><h3 id="Create-manage-py"><a href="#Create-manage-py" class="headerlink" title="Create manage.py"></a>Create manage.py</h3><p>We need the ability of running our application without setting env variables everytime. This goal can be achieved using <a href="https://flask-script.readthedocs.io/en/latest/" target="_blank" rel="noopener">flask-script</a> package. At first we should create a file called manage.py<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch manage.py</span><br></pre></td></tr></table></figure></p><p>Next step is getting this manage.py ready.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br><span class="line">manager = Manager(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@manager.command</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runserver</span><span class="params">()</span>:</span></span><br><span class="line">    app.run(debug=<span class="keyword">True</span>, host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><p>As you see there is an unknown function create_app inside the app package. Now we’ll make this function known.<br>I start from creating the package.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir app</span><br><span class="line">touch app/__init__.py</span><br></pre></td></tr></table></figure></p><p>And then make the target function<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure></p><p>It’s now our app ready and can be run by calling.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver</span><br></pre></td></tr></table></figure></p><h3 id="Add-storage"><a href="#Add-storage" class="headerlink" title="Add storage"></a>Add storage</h3><p>As we’ll deal with the kNN classifier we need to remember the clusters after the training process. The simplies way is to store serialized version of the classifier in a file. Let’s create this file.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir storage</span><br><span class="line">touch storage/classifier.txt</span><br></pre></td></tr></table></figure></p><h3 id="Create-settings-file"><a href="#Create-settings-file" class="headerlink" title="Create settings file"></a>Create settings file</h3><p>Finally we need to create settings file where we’ll have the paths of the application’s base directory and the classifier storage.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch settings.py</span><br></pre></td></tr></table></figure></p><p>And file’s content<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.getcwd()</span><br><span class="line">CLASSIFIER_STORAGE = os.path.join(BASE_DIR, <span class="string">'storage/classifier.txt'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="The-app-itself"><a href="#The-app-itself" class="headerlink" title="The app itself"></a>The app itself</h2><h3 id="Write-views"><a href="#Write-views" class="headerlink" title="Write views"></a>Write views</h3><p>The first step is to specify handlers for incoming requests. We’ll develop a SPA so the first handler will always return index.html page.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_root_view</span><span class="params">(app)</span>:</span></span><br><span class="line"><span class="meta">    @app.route('/', defaults=&#123;'path': ''&#125;)</span></span><br><span class="line"><span class="meta">    @app.route('/&lt;path:path&gt;')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(path)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br></pre></td></tr></table></figure></p><p>Besides this view we also must create an api endpoint for predictions.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PredictDigitView</span><span class="params">(MethodView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="Construct-prediction-logic"><a href="#Construct-prediction-logic" class="headerlink" title="Construct prediction logic"></a>Construct prediction logic</h3><p>For our prediction view we need 2 things: kNN classifier and image processor.<br>Then let’s make a repo for getting and updating our classifier.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassifierRepo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage)</span>:</span></span><br><span class="line">        self.storage = storage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.storage, <span class="string">'rb'</span>) <span class="keyword">as</span> out:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                classifier_str = out.read()</span><br><span class="line">                <span class="keyword">if</span> classifier_str != <span class="string">''</span>:</span><br><span class="line">                    <span class="keyword">return</span> pickle.loads(classifier_str)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, classifier)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.storage, <span class="string">'wb'</span>) <span class="keyword">as</span> in_:</span><br><span class="line">            pickle.dump(classifier, in_)</span><br></pre></td></tr></table></figure></p><p>Also we need a factory to create and fit our kNN model.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassifierFactory</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_with_fit</span><span class="params">(data, target)</span>:</span></span><br><span class="line">        (X_train, X_test, y_train, y_test) = train_test_split(</span><br><span class="line">            data, target, test_size=<span class="number">0.25</span>, random_state=<span class="number">42</span></span><br><span class="line">        )</span><br><span class="line">        model = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">        model.fit(X_train, y_train)</span><br><span class="line">        <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></p><p>Image processor will be represented by the lots of functions to convert our image from data uri to the flat numpy array of the 8x8 greyscaled image with intensity form 0 to 16(like the original ones from digits dataset).<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_uri_to_image</span><span class="params">(uri)</span>:</span></span><br><span class="line">    encoded_data = uri.split(<span class="string">','</span>)[<span class="number">1</span>]</span><br><span class="line">    image = base64.b64decode(encoded_data)</span><br><span class="line">    <span class="keyword">return</span> Image.open(BytesIO(image))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_transparent_background</span><span class="params">(image)</span>:</span></span><br><span class="line">    image_arr = np.array(image)</span><br><span class="line">    alpha1 = <span class="number">0</span></span><br><span class="line">    r2, g2, b2, alpha2 = <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    red, green, blue, alpha = image_arr[:, :, <span class="number">0</span>], image_arr[:, :, <span class="number">1</span>], image_arr[:, :, <span class="number">2</span>], image_arr[:, :, <span class="number">3</span>]</span><br><span class="line">    mask = (alpha == alpha1)</span><br><span class="line">    image_arr[:, :, :<span class="number">4</span>][mask] = [r2, g2, b2, alpha2]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(image_arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_image</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> image.resize((<span class="number">8</span>, <span class="number">8</span>), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">white_to_black</span><span class="params">(image)</span>:</span></span><br><span class="line">    image_arr = np.array(image)</span><br><span class="line">    image_arr[image_arr &gt; <span class="number">230</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(image_arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_intensity</span><span class="params">(image)</span>:</span></span><br><span class="line">    image_arr = np.array(image)</span><br><span class="line">    image_arr = exposure.rescale_intensity(image_arr, out_range=(<span class="number">0</span>, <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(image_arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_classifier_input_format</span><span class="params">(data_uri)</span>:</span></span><br><span class="line">    raw_image = data_uri_to_image(data_uri)</span><br><span class="line">    image_with_background = replace_transparent_background(raw_image).convert(<span class="string">'L'</span>)</span><br><span class="line">    resized_image = resize_image(image_with_background)</span><br><span class="line">    inverted_image = white_to_black(resized_image)</span><br><span class="line">    low_intensed_image = reduce_intensity(inverted_image)</span><br><span class="line">    flat_image = np.array(low_intensed_image).flatten()</span><br><span class="line">    <span class="keyword">return</span> np.array([flat_image])</span><br></pre></td></tr></table></figure></p><p>It’s almost done. The only thing to finish our view is to combine all the things above into a service.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app.classifier <span class="keyword">import</span> ClassifierFactory</span><br><span class="line"><span class="keyword">from</span> app.utils <span class="keyword">import</span> to_classifier_input_format</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PredictDigitService</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repo)</span>:</span></span><br><span class="line">        self.repo = repo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, image_data_uri)</span>:</span></span><br><span class="line">        classifier = self.repo.get()</span><br><span class="line">        <span class="keyword">if</span> classifier <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            digits = load_digits()</span><br><span class="line">            classifier = ClassifierFactory.create(digits.data, digits.target)</span><br><span class="line">            self.repo.update(classifier)</span><br><span class="line">        x = to_classifier_input_format(image_data_uri)</span><br><span class="line">        prediction = classifier.predict(x)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> prediction</span><br></pre></td></tr></table></figure></p><p>Use this service in our view.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PredictDigitView</span><span class="params">(MethodView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        repo = ClassifierRepo(CLASSIFIER_STORAGE)</span><br><span class="line">        service = PredictDigitService(repo)</span><br><span class="line">        image_data_uri = request.json[<span class="string">'image'</span>]</span><br><span class="line">        prediction = service.handle(image_data_uri)</span><br><span class="line">        <span class="keyword">return</span> Response(str(prediction).encode(), status=<span class="number">200</span>)</span><br></pre></td></tr></table></figure></p><p>And initialize handlers by calling this function inside the <strong>create_app</strong>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_urls</span><span class="params">(app)</span>:</span></span><br><span class="line">    app.add_url_rule(</span><br><span class="line">        <span class="string">'/api/predict'</span>,</span><br><span class="line">        view_func=PredictDigitView.as_view(<span class="string">'predict_digit'</span>),</span><br><span class="line">        methods=[<span class="string">'POST'</span>]</span><br><span class="line">    )</span><br><span class="line">    create_root_view(app)</span><br></pre></td></tr></table></figure></p><p>So the final version of __init__.py inside the app folder<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> .urls <span class="keyword">import</span> init_urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    init_urls(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure></p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>Now you can test our app. Let’s run the application<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver</span><br></pre></td></tr></table></figure></p><p>And send an image in base64 format. You can do it by downloading <a href="http://training.databricks.com/databricks_guide/digit.png" target="_blank" rel="noopener">this image</a>, then convert it to base64 using <a href="https://www.base64-image.de/" target="_blank" rel="noopener">this resource</a>, copy the code and save it in the file called test_request.json. Now we can send this file to get a prediction.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'http://localhost:5000/api/predict'</span> -X <span class="string">"POST"</span> -H <span class="string">"Content-Type: application/json"</span> -d @test_request.json -i &amp;&amp; <span class="built_in">echo</span> -e <span class="string">'\n\n'</span></span><br></pre></td></tr></table></figure></p><p>You should see the following output.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) Teimurs-MacBook-Pro:digits-recognizer teimurgasanov$ curl &apos;http://localhost:5000/api/predict&apos; -X &quot;POST&quot; -H &quot;Content-Type: application/json&quot; -d @test_request.json -i &amp;&amp; echo -e &apos;\n\n&apos;</span><br><span class="line">HTTP/1.1 100 Continue</span><br><span class="line"></span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 1</span><br><span class="line">Server: Werkzeug/0.14.1 Python/3.6.3</span><br><span class="line">Date: Tue, 27 Mar 2018 07:02:08 GMT</span><br><span class="line"></span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><p>As you see our web app correctly detected that it is 4.</p><h2 id="Final-result"><a href="#Final-result" class="headerlink" title="Final result"></a>Final result</h2><p>You can find the code from this article in my <a href="https://github.com/teimurjan/digits-recognizer" target="_blank" rel="noopener">Github repository</a>.</p><h1 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h1><p>In the third and also the last part of building our digit recognizer, we’ll create a React application to draw digits and send them to our classifier.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It is the second part of my long journey to creating the web application for recognition handwritten digits. Here I’ll explain how to int
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Digits Recognizer using Python and React. Train the model.</title>
    <link href="https://attractor-software.github.io/2018/03/25/digits-recognizer-1/"/>
    <id>https://attractor-software.github.io/2018/03/25/digits-recognizer-1/</id>
    <published>2018-03-25T08:02:19.000Z</published>
    <updated>2018-03-30T07:02:26.411Z</updated>
    
    <content type="html"><![CDATA[<p>Today’s topic is like an introduction into the combination of computer vision and machine learning. All that I’ll do here is just fitting kNN model with the data of handwritten digits taken from the <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST Database</a> and also checking its accuracy. </p><h2 id="Set-up-environment"><a href="#Set-up-environment" class="headerlink" title="Set up environment"></a>Set up environment</h2><p>I’ll be using <a href="https://anaconda.org/anaconda/python" target="_blank" rel="noopener">Anaconda</a> as my environment so I’ll skip the step about installing the dependencies.</p><h2 id="Import-dependencies"><a href="#Import-dependencies" class="headerlink" title="Import dependencies"></a>Import dependencies</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure><h2 id="Prepare-data"><a href="#Prepare-data" class="headerlink" title="Prepare data"></a>Prepare data</h2><h3 id="Load-data"><a href="#Load-data" class="headerlink" title="Load data"></a>Load data</h3><p>The dataset from <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST Database</a> is available in the datasets module of sklearn, so let’s start with loading the data.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digits = datasets.load_digits()</span><br></pre></td></tr></table></figure></p><h3 id="Split-the-data"><a href="#Split-the-data" class="headerlink" title="Split the data"></a>Split the data</h3><p>Now we need to have two different datasets: one for testing and the other for training our model.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(X_train, X_test, y_train, y_test) = train_test_split(</span><br><span class="line">    digits.data, digits.target, test_size=<span class="number">0.25</span>, random_state=<span class="number">42</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="Fit-the-model"><a href="#Fit-the-model" class="headerlink" title="Fit the model"></a>Fit the model</h2><h3 id="Find-best-k"><a href="#Find-best-k" class="headerlink" title="Find best k"></a>Find best k</h3><p>We can’t take k out of our mind, so let’s train model and evaluate accuracy for different k.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ks = np.arange(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">scores = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> ks:</span><br><span class="line">    model = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>)</span><br><span class="line">    score.mean()</span><br><span class="line">    scores.append(score.mean())</span><br><span class="line">plt.plot(scores, ks)</span><br><span class="line">plt.xlabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'k'</span>)</span><br></pre></td></tr></table></figure></p><p>As the output we can see such plot:</p><img src="/blog/2018/03/25/digits-recognizer-1/find-best-k.jpg"><p>Looking at this chart we can understand that the best accuracy was reached when k was 3.<br>So from now, we’ll be using k=3 for our model.</p><h3 id="Evaluate-the-model-on-the-test-data"><a href="#Evaluate-the-model-on-the-test-data" class="headerlink" title="Evaluate the model on the test data"></a>Evaluate the model on the test data</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">z = model.predict(X_test)</span><br></pre></td></tr></table></figure><p>Let’s now create a classification report to see the accuracy<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(classification_report(y_test, z))</span><br></pre></td></tr></table></figure></p><img src="/blog/2018/03/25/digits-recognizer-1/classification-score.png"><p>Amazing! We reached 99% accuracy!</p><h1 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h1><p>In the next article I’ll create a <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> Application to draw the digits in order to join it with the classifier into a web application.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today’s topic is like an introduction into the combination of computer vision and machine learning. All that I’ll do here is just fitting
      
    
    </summary>
    
    
  </entry>
  
</feed>
